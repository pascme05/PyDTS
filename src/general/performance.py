#######################################################################################################################
#######################################################################################################################
# Title:        PyDTS (Python Deep Timeseries Simulation)
# Topic:        Black-Box Modeling
# File:         performance
# Date:         03.11.2023
# Author:       Dr. Pascal A. Schirmer
# Version:      V.0.1
# Copyright:    Pascal Schirmer
#######################################################################################################################
#######################################################################################################################


#######################################################################################################################
# Import libs
#######################################################################################################################
# ==============================================================================
# Internal
# ==============================================================================
from sklearn.metrics import f1_score
from sklearn.metrics import mean_absolute_error
from sklearn.metrics import mean_squared_error
from sklearn.metrics import r2_score

# ==============================================================================
# External
# ==============================================================================
import numpy as np


#######################################################################################################################
# Function
#######################################################################################################################
def performance(yPred, yTrue, yPred_L, yTrue_L, setupDat):
    ###################################################################################################################
    # MSG IN
    ###################################################################################################################
    print("INFO: Calculating Performance")

    ###################################################################################################################
    # Initialisation
    ###################################################################################################################
    # ==============================================================================
    # Variables
    # ==============================================================================
    Acc  = np.zeros(len(setupDat['out']))
    F1   = np.zeros(len(setupDat['out']))
    Mae  = np.zeros(len(setupDat['out']))
    R2 = np.zeros(len(setupDat['out']))
    TECA = np.zeros(len(setupDat['out']))
    Rmse = np.zeros(len(setupDat['out']))
    Max = np.zeros(len(setupDat['out']))
    Est  = np.zeros(len(setupDat['out']))
    Tru  = np.zeros(len(setupDat['out']))

    ###################################################################################################################
    # Pre-Processing
    ###################################################################################################################
    Eng = np.sum(np.sum(abs(yTrue)))

    ###################################################################################################################
    # Calculation
    ###################################################################################################################
    # ==============================================================================
    # Output
    # ==============================================================================
    for i in range(0, len(setupDat['out'])):
        Acc[i]  = 1 - (sum(abs(yTrue_L[:, i] - yPred_L[:, i])) / len(yTrue_L))
        F1[i]   = f1_score(yTrue_L[:, i], yPred_L[:, i], average='weighted')
        R2[i] = r2_score(yTrue[:, i], yPred[:, i])
        TECA[i] = 1 - sum(abs(yPred[:, i] - yTrue[:, i])) / (sum(yTrue[:, i]) + 1e-6) / 2
        Rmse[i] = np.sqrt(mean_squared_error(yTrue[:, i], yPred[:, i]))
        Mae[i]  = mean_absolute_error(yTrue[:, i], yPred[:, i])
        Max[i] = np.max(abs(yTrue[:, i] - yPred[:, i]))
        Est[i]  = sum(abs(yPred[:, i])) / Eng
        Tru[i]  = sum(abs(yTrue[:, i])) / Eng

    # ==============================================================================
    # Average
    # ==============================================================================
    Acc_avg = np.nanmean(Acc)
    F1_avg = np.nanmean(F1)
    R2_avg = np.nanmean(R2)
    TECA_avg = np.nanmean(TECA)
    Rmse_avg = np.nanmean(Rmse)
    Mae_avg = np.nanmean(Mae)
    Max_avg = np.nanmean(Max)
    Est_avg = np.nanmean(Est) * len(setupDat['out'])
    Tru_avg = np.nanmean(Tru) * len(setupDat['out'])

    ###################################################################################################################
    # Post-Processing
    ###################################################################################################################
    results = np.c_[Acc, F1, R2, TECA, Rmse, Mae, Max, Est, Tru]
    resultsAvg = np.concatenate((Acc_avg, F1_avg, R2_avg, TECA_avg, Rmse_avg, Mae_avg, Max_avg, Est_avg, Tru_avg), axis=None)

    ###################################################################################################################
    # Return
    ###################################################################################################################
    return [results, resultsAvg]
